temp=data.frame(n1=n1,
n2=n2,
p=p,
r=r,
beta=beta,
myLevel=level$myLevel,
oracleLevel=level$oracleLevel)
Out=rbind(Out,temp)
}
Out=Out[-1,]
row.names(Out)=NULL
write.csv(Out,"level.csv",row.names = FALSE)
Out'
''
Out
source("./stat.R")
library(ggplot2)
library(xtable)
simulateLevel <- function(n1,n2,p,r,beta,B=200){
theEig <- rep(1,p)
if(r!=0){
theEig[1:r] <- rep(p^beta,r)+runif(r,0,1)
}
temp <- newModelGenerator(theEig)
normalModelSimulator <- temp$normalModelSimulator
V <- temp$V[,1:r]
myPvalue <- NULL
oraclePvalue <- NULL
pb <- txtProgressBar(style=3)
for(i in 1:B){
X1 <- normalModelSimulator(n1)
X2 <- normalModelSimulator(n2)
myPvalue[i] <- doTest(X1,X2,n1,n2,r=r)
# oracle: V known
temp <- chenStat(X1%*%Null(V),X2%*%Null(V),n1,n2)$stat
tempOracleStat=n1*n2*temp/(sqrt(2*p)*(n1+n2)*1)
oraclePvalue[i]=pnorm(tempOracleStat,0,1,lower.tail = FALSE)
setTxtProgressBar(pb,i/B)
}
close(pb)
myLevel=sum(myPvalue<0.05)/B
oracleLevel=sum(oraclePvalue<0.05)/B
list(myLevel=myLevel,oracleLevel=oracleLevel)
}
Out=data.frame(n1=0,n2=0,p=0,r=0,beta=0,myLevel=0,oracleLevel=0)
for(beta in c(1))
for(r in 1)
for(p in c(400,800,1200))
for(n in c(200)){
n1=n
n2=n
level=simulateLevel(n1,n2,p,r,beta)
temp=data.frame(n1=n1,
n2=n2,
p=p,
r=r,
beta=beta,
myLevel=level$myLevel,
oracleLevel=level$oracleLevel)
Out=rbind(Out,temp)
}
Out=Out[-1,]
row.names(Out)=NULL
write.csv(Out,"level.csv",row.names = FALSE)
Out
source("./stat.R")
library(ggplot2)
library(xtable)
simulateLevel <- function(n1,n2,p,r,beta,B=1000){
theEig <- rep(1,p)
if(r!=0){
theEig[1:r] <- rep(p^beta,r)+runif(r,0,1)
}
temp <- newModelGenerator(theEig)
normalModelSimulator <- temp$normalModelSimulator
V <- temp$V[,1:r]
myPvalue <- NULL
oraclePvalue <- NULL
pb <- txtProgressBar(style=3)
for(i in 1:B){
X1 <- normalModelSimulator(n1)
X2 <- normalModelSimulator(n2)
myPvalue[i] <- doTest(X1,X2,n1,n2,r=r)
# oracle: V known
temp <- chenStat(X1%*%Null(V),X2%*%Null(V),n1,n2)$stat
tempOracleStat=n1*n2*temp/(sqrt(2*p)*(n1+n2)*1)
oraclePvalue[i]=pnorm(tempOracleStat,0,1,lower.tail = FALSE)
setTxtProgressBar(pb,i/B)
}
close(pb)
myLevel=sum(myPvalue<0.05)/B
oracleLevel=sum(oraclePvalue<0.05)/B
list(myLevel=myLevel,oracleLevel=oracleLevel)
}
Out=data.frame(n1=0,n2=0,p=0,r=0,beta=0,myLevel=0,oracleLevel=0)
for(beta in c(1))
for(r in 1)
for(p in c(400,800,1200))
for(n in c(200)){
n1=n
n2=n
level=simulateLevel(n1,n2,p,r,beta)
temp=data.frame(n1=n1,
n2=n2,
p=p,
r=r,
beta=beta,
myLevel=level$myLevel,
oracleLevel=level$oracleLevel)
Out=rbind(Out,temp)
}
Out=Out[-1,]
row.names(Out)=NULL
write.csv(Out,"level.csv",row.names = FALSE)
Out
source("./stat.R")
library(ggplot2)
library(xtable)
simulateLevel <- function(n1,n2,p,r,beta,B=200){
theEig <- rep(1,p)
if(r!=0){
theEig[1:r] <- rep(p^beta,r)+runif(r,0,1)
}
temp <- newModelGenerator(theEig)
normalModelSimulator <- temp$normalModelSimulator
V <- temp$V[,1:r]
myPvalue <- NULL
oraclePvalue <- NULL
pb <- txtProgressBar(style=3)
for(i in 1:B){
X1 <- normalModelSimulator(n1)
X2 <- normalModelSimulator(n2)
myPvalue[i] <- doTest(X1,X2,n1,n2,r=r)
# oracle: V known
temp <- chenStat(X1%*%Null(V),X2%*%Null(V),n1,n2)$stat
tempOracleStat=n1*n2*temp/(sqrt(2*p)*(n1+n2)*1)
oraclePvalue[i]=pnorm(tempOracleStat,0,1,lower.tail = FALSE)
setTxtProgressBar(pb,i/B)
}
close(pb)
myLevel=sum(myPvalue<0.05)/B
oracleLevel=sum(oraclePvalue<0.05)/B
list(myLevel=myLevel,oracleLevel=oracleLevel)
}
Out=data.frame(n1=0,n2=0,p=0,r=0,beta=0,myLevel=0,oracleLevel=0)
for(beta in c(1))
for(r in 1)
for(p in c(400,800,1200))
for(n in c(300)){
n1=n
n2=n
level=simulateLevel(n1,n2,p,r,beta)
temp=data.frame(n1=n1,
n2=n2,
p=p,
r=r,
beta=beta,
myLevel=level$myLevel,
oracleLevel=level$oracleLevel)
Out=rbind(Out,temp)
}
source("./stat.R")
library(ggplot2)
library(xtable)
simulateLevel <- function(n1,n2,p,r,beta,B=200){
theEig <- rep(1,p)
if(r!=0){
theEig[1:r] <- rep(p^beta,r)+runif(r,0,1)
}
temp <- newModelGenerator(theEig)
normalModelSimulator <- temp$normalModelSimulator
V <- temp$V[,1:r]
myPvalue <- NULL
oraclePvalue <- NULL
pb <- txtProgressBar(style=3)
for(i in 1:B){
X1 <- normalModelSimulator(n1)
X2 <- normalModelSimulator(n2)
myPvalue[i] <- doTest(X1,X2,n1,n2,r=r)
# oracle: V known
temp <- chenStat(X1%*%Null(V),X2%*%Null(V),n1,n2)$stat
tempOracleStat=n1*n2*temp/(sqrt(2*p)*(n1+n2)*1)
oraclePvalue[i]=pnorm(tempOracleStat,0,1,lower.tail = FALSE)
setTxtProgressBar(pb,i/B)
}
close(pb)
myLevel=sum(myPvalue<0.05)/B
oracleLevel=sum(oraclePvalue<0.05)/B
list(myLevel=myLevel,oracleLevel=oracleLevel)
}
Out=data.frame(n1=0,n2=0,p=0,r=0,beta=0,myLevel=0,oracleLevel=0)
for(beta in c(1))
for(r in 1)
for(p in c(400,800,1200))
for(n in c(100)){
n1=n
n2=n
level=simulateLevel(n1,n2,p,r,beta)
temp=data.frame(n1=n1,
n2=n2,
p=p,
r=r,
beta=beta,
myLevel=level$myLevel,
oracleLevel=level$oracleLevel)
Out=rbind(Out,temp)
}
Out=Out[-1,]
row.names(Out)=NULL
write.csv(Out,"level.csv",row.names = FALSE)
Out
source("./stat.R")
library(ggplot2)
library(xtable)
simulateLevel <- function(n1,n2,p,r,beta,B=200){
theEig <- rep(1,p)
if(r!=0){
theEig[1:r] <- rep(p^beta,r)+runif(r,0,1)
}
temp <- newModelGenerator(theEig)
normalModelSimulator <- temp$normalModelSimulator
V <- temp$V[,1:r]
myPvalue <- NULL
oraclePvalue <- NULL
pb <- txtProgressBar(style=3)
for(i in 1:B){
X1 <- normalModelSimulator(n1)
X2 <- normalModelSimulator(n2)
myPvalue[i] <- doTest(X1,X2,n1,n2,r=r)
# oracle: V known
temp <- chenStat(X1%*%Null(V),X2%*%Null(V),n1,n2)$stat
tempOracleStat=n1*n2*temp/(sqrt(2*p)*(n1+n2)*1)
oraclePvalue[i]=pnorm(tempOracleStat,0,1,lower.tail = FALSE)
setTxtProgressBar(pb,i/B)
}
close(pb)
myLevel=sum(myPvalue<0.05)/B
oracleLevel=sum(oraclePvalue<0.05)/B
list(myLevel=myLevel,oracleLevel=oracleLevel)
}
Out=data.frame(n1=0,n2=0,p=0,r=0,beta=0,myLevel=0,oracleLevel=0)
for(beta in c(1))
for(r in 1)
for(p in c(200,400,600))
for(n in c(100)){
n1=n
n2=n
level=simulateLevel(n1,n2,p,r,beta)
temp=data.frame(n1=n1,
n2=n2,
p=p,
r=r,
beta=beta,
myLevel=level$myLevel,
oracleLevel=level$oracleLevel)
Out=rbind(Out,temp)
}
Out=Out[-1,]
row.names(Out)=NULL
write.csv(Out,"level.csv",row.names = FALSE)
Out
source("./stat.R")
library(ggplot2)
library(xtable)
simulateLevel <- function(n1,n2,p,r,beta,B=1000){
theEig <- rep(1,p)
if(r!=0){
theEig[1:r] <- rep(p^beta,r)+runif(r,0,1)
}
temp <- newModelGenerator(theEig)
normalModelSimulator <- temp$normalModelSimulator
V <- temp$V[,1:r]
myPvalue <- NULL
oraclePvalue <- NULL
pb <- txtProgressBar(style=3)
for(i in 1:B){
X1 <- normalModelSimulator(n1)
X2 <- normalModelSimulator(n2)
myPvalue[i] <- doTest(X1,X2,n1,n2,r=r)
# oracle: V known
temp <- chenStat(X1%*%Null(V),X2%*%Null(V),n1,n2)$stat
tempOracleStat=n1*n2*temp/(sqrt(2*p)*(n1+n2)*1)
oraclePvalue[i]=pnorm(tempOracleStat,0,1,lower.tail = FALSE)
setTxtProgressBar(pb,i/B)
}
close(pb)
myLevel=sum(myPvalue<0.05)/B
oracleLevel=sum(oraclePvalue<0.05)/B
list(myLevel=myLevel,oracleLevel=oracleLevel)
}
Out=data.frame(n1=0,n2=0,p=0,r=0,beta=0,myLevel=0,oracleLevel=0)
for(beta in c(0.2,0.5,1,2))
for(r in 1)
for(p in c(200,400,600))
for(n in c(100)){
n1=n
n2=n
level=simulateLevel(n1,n2,p,r,beta)
temp=data.frame(n1=n1,
n2=n2,
p=p,
r=r,
beta=beta,
myLevel=level$myLevel,
oracleLevel=level$oracleLevel)
Out=rbind(Out,temp)
}
source("./stat.R")
library(ggplot2)
library(xtable)
simulateLevel <- function(n1,n2,p,r,beta,B=1000){
theEig <- rep(1,p)
if(r!=0){
theEig[1:r] <- rep(p^beta,r)+runif(r,0,1)
}
temp <- newModelGenerator(theEig)
normalModelSimulator <- temp$normalModelSimulator
V <- temp$V[,1:r]
myPvalue <- NULL
oraclePvalue <- NULL
pb <- txtProgressBar(style=3)
for(i in 1:B){
X1 <- normalModelSimulator(n1)
X2 <- normalModelSimulator(n2)
myPvalue[i] <- doTest(X1,X2,n1,n2,r=r)
# oracle: V known
temp <- chenStat(X1%*%Null(V),X2%*%Null(V),n1,n2)$stat
tempOracleStat=n1*n2*temp/(sqrt(2*p)*(n1+n2)*1)
oraclePvalue[i]=pnorm(tempOracleStat,0,1,lower.tail = FALSE)
setTxtProgressBar(pb,i/B)
}
close(pb)
myLevel=sum(myPvalue<0.05)/B
oracleLevel=sum(oraclePvalue<0.05)/B
list(myLevel=myLevel,oracleLevel=oracleLevel)
}
Out=data.frame(n1=0,n2=0,p=0,r=0,beta=0,myLevel=0,oracleLevel=0)
for(beta in c(0.2,0.5,1,2))
for(r in 1)
for(p in c(200,400,600))
for(n in c(120)){
n1=n
n2=n
level=simulateLevel(n1,n2,p,r,beta)
temp=data.frame(n1=n1,
n2=n2,
p=p,
r=r,
beta=beta,
myLevel=level$myLevel,
oracleLevel=level$oracleLevel)
Out=rbind(Out,temp)
}
qqplot(rnorm(10000))
qqnorm(rnorm(10000))
abline(a=0,b=1)
qqnorm(rnorm(10000)*100/101)
qqnorm(rnorm(10000))
qqnorm(rnorm(10000)*100/101)
qqnorm(rnorm(10000)*100/101)
qqnorm(rnorm(10000))
qqnorm(rnorm(10000)*100/101)
qqnorm(rnorm(10000)*100/101)
abline(a=0,b=1)
qqnorm(rnorm(10000))
abline(a=0,b=1)
source("./stat.R")
library(ggplot2)
library(xtable)
simulateLevel <- function(n1,n2,p,r,beta,B=1000){
theEig <- rep(1,p)
if(r!=0){
theEig[1:r] <- rep(p^beta,r)+runif(r,0,1)
}
temp <- newModelGenerator(theEig)
normalModelSimulator <- temp$normalModelSimulator
V <- temp$V[,1:r]
myPvalue <- NULL
oraclePvalue <- NULL
pb <- txtProgressBar(style=3)
for(i in 1:B){
X1 <- normalModelSimulator(n1)
X2 <- normalModelSimulator(n2)
myPvalue[i] <- doTest(X1,X2,n1,n2,r=r)
# oracle: V known
temp <- chenStat(X1%*%Null(V),X2%*%Null(V),n1,n2)$stat
tempOracleStat=n1*n2*temp/(sqrt(2*p)*(n1+n2)*1)
oraclePvalue[i]=pnorm(tempOracleStat,0,1,lower.tail = FALSE)
setTxtProgressBar(pb,i/B)
}
close(pb)
myLevel=sum(myPvalue<0.05)/B
oracleLevel=sum(oraclePvalue<0.05)/B
list(myLevel=myLevel,oracleLevel=oracleLevel)
}
Out=data.frame(n1=0,n2=0,p=0,r=0,beta=0,myLevel=0,oracleLevel=0)
for(beta in c(0.2,0.5,1,2))
for(r in 1)
for(p in c(200,400,600))
for(n in c(120)){
n1=n
n2=n
level=simulateLevel(n1,n2,p,r,beta)
temp=data.frame(n1=n1,
n2=n2,
p=p,
r=r,
beta=beta,
myLevel=level$myLevel,
oracleLevel=level$oracleLevel)
Out=rbind(Out,temp)
}
Out=Out[-1,]
row.names(Out)=NULL
write.csv(Out,"level.csv",row.names = FALSE)
Out
source("./stat.R")
library(ggplot2)
library(xtable)
simulateLevel <- function(n1,n2,p,r,beta,B=1000){
theEig <- rep(1,p)
if(r!=0){
theEig[1:r] <- rep(p^beta,r)+runif(r,0,1)
}
temp <- newModelGenerator(theEig)
normalModelSimulator <- temp$normalModelSimulator
V <- temp$V[,1:r]
myPvalue <- NULL
oraclePvalue <- NULL
pb <- txtProgressBar(style=3)
for(i in 1:B){
X1 <- normalModelSimulator(n1)
X2 <- normalModelSimulator(n2)
myPvalue[i] <- doTest(X1,X2,n1,n2,r=r)
# oracle: V known
temp <- chenStat(X1%*%Null(V),X2%*%Null(V),n1,n2)$stat
tempOracleStat=n1*n2*temp/(sqrt(2*p)*(n1+n2)*1)
oraclePvalue[i]=pnorm(tempOracleStat,0,1,lower.tail = FALSE)
setTxtProgressBar(pb,i/B)
}
close(pb)
myLevel=sum(myPvalue<0.05)/B
oracleLevel=sum(oraclePvalue<0.05)/B
list(myLevel=myLevel,oracleLevel=oracleLevel)
}
Out=data.frame(n1=0,n2=0,p=0,r=0,beta=0,myLevel=0,oracleLevel=0)
for(beta in c(0.5,1,2))
for(r in 1)
for(p in c(600,800))
for(n in c(120)){
n1=n
n2=n
level=simulateLevel(n1,n2,p,r,beta)
temp=data.frame(n1=n1,
n2=n2,
p=p,
r=r,
beta=beta,
myLevel=level$myLevel,
oracleLevel=level$oracleLevel)
Out=rbind(Out,temp)
}
jj[1]<-1
debugSource('~/firstPb/code/revision1/testLevel.R', echo=TRUE)
qqnorm(myLevel)
qqnorm(myDis)
abline(a=0,b=1)
qqnorm(oracleLevel)
qqnorm(oracleDis)
abline(a=0,b=1)
n1
p
theEig <- rep(1,p)
if(r!=0){
theEig[1:r] <- rep(p^beta,r)+runif(r,0,1)
}
temp <- newModelGenerator(theEig)
normalModelSimulator <- temp$normalModelSimulator
V <- temp$V[,1:r]
x <- normalModelSimulator(100)
S1 <- var(x)
trace1 <- sum(eigen(S1, symmetric = TRUE)$values[-(1:r)])
trace1
trace1/p
12/sqrt(p)
debugSource('~/firstPb/code/revision1/testLevel.R', echo=TRUE)
qqnorm(myDis)
abline(a=0,b=1)
qqnorm(oracleDis)
abline(a=0,b=1)
mean(myDis)
mean(oracleD9s)
mean(oracleDis)
12/sqrt(p)
8/sqrt(p)
6/sqrt(p)
x <- normalModelSimulator(100)
S1 <- var(x)
trace1 <- sum(eigen(S1, symmetric = TRUE)$values[-(1:r)])
trace1
ttt <- eigen(S1, symmetric = TRUE)$values
ttt
head(ttt)
ttt[-1]
mean(ttt[-1])
sum(ttt[-1])
x <- normalModelSimulator(100)
S1 <- var(x)
ttt <- eigen(S1, symmetric = TRUE)$values
sum(ttt[-1])
sum(c(ttt[-1],2))
sum(c(ttt[-1],ttt[2]))
