r <- 2
theEig <- rep(1,p)
beta <- 1
if(r!=0){
theEig[1:r] <- rep(1,r)*(p^beta)
}
temp <- newModelGenerator(theEig,theDistribution="normal")
modelSimulator <- temp$modelSimulator
myQQplot <- function(x,y){
sx <- sort(x)
sy <- sort(y)
lenx <- length(sx)
leny <- length(sy)
if (leny < lenx)
sx <- approx(1L:lenx, sx, n = leny)$y
if (leny > lenx)
sy <- approx(1L:leny, sy, n = lenx)$y
d <- data.frame(sx,sy)
ggplot(d,aes(sx,sy))+
geom_point(aes(colour=abs(sy-sx)),size=2)+
scale_colour_gradient(low='royalblue',high='royalblue4',guide='none')+
annotate("segment",x=-5,xend=5,y=-5,yend=5,colour="red")+
xlab("Theoretical Quantiles")+
ylab("Sample Quantiles")+
scale_x_continuous(breaks=seq(-5,5,2.5))+
scale_y_continuous(breaks=seq(-5,5,2.5))+
theme_bw()+
theme(
axis.title.y= element_text(size=rel(2),angle=90),
axis.title.x= element_text(size=rel(2)),
axis.text= element_text(size=rel(1.8))
)
}
source("../stat.R")
library(ggplot2)
nnn <-5000
p <- 500
r <- 2
theEig <- rep(1,p)
beta <- 1
if(r!=0){
theEig[1:r] <- rep(1,r)*(p^beta)
}
temp <- newModelGenerator(theEig,theDistribution="normal")
modelSimulator <- temp$modelSimulator
myQQplot <- function(x,y){
sx <- sort(x)
sy <- sort(y)
lenx <- length(sx)
leny <- length(sy)
if (leny < lenx)
sx <- approx(1L:lenx, sx, n = leny)$y
if (leny > lenx)
sy <- approx(1L:leny, sy, n = lenx)$y
d <- data.frame(sx,sy)
ggplot(d,aes(sx,sy))+
geom_point(aes(colour=abs(sy-sx)),size=2)+
scale_colour_gradient(low='royalblue',high='royalblue4',guide='none')+
annotate("segment",x=-5,xend=5,y=-5,yend=5,colour="red")+
xlab("Theoretical Quantiles")+
ylab("Sample Quantiles")+
scale_x_continuous(breaks=seq(-5,5,2.5))+
scale_y_continuous(breaks=seq(-5,5,2.5))+
theme_bw()+
theme(
axis.title.y= element_text(size=rel(2),angle=90),
axis.title.x= element_text(size=rel(2)),
axis.text= element_text(size=rel(1.8))
)
}
n <- 50
n1 <- n
n2 <- n
pb <- txtProgressBar(style = 3)
myImproved <- vector()
myNew <- vector()
for (i in 1:nnn){
# data generation
X1 <- modelSimulator(n1)
X2 <- modelSimulator(n2)
myImproved[i] <- myStat2(X1,X2,n1,n2,r=r)$studentStat
myNew[i] <- myStatFinal(X1,X2,n1,n2,r=r)$studentStat
setTxtProgressBar(pb, i/nnn)
}
source("../stat.R")
library(ggplot2)
nnn <-500
#nnn <-5000
p <- 500
r <- 2
theEig <- rep(1,p)
beta <- 1
if(r!=0){
theEig[1:r] <- rep(1,r)*(p^beta)
}
temp <- newModelGenerator(theEig,theDistribution="normal")
modelSimulator <- temp$modelSimulator
myQQplot <- function(x,y){
sx <- sort(x)
sy <- sort(y)
lenx <- length(sx)
leny <- length(sy)
if (leny < lenx)
sx <- approx(1L:lenx, sx, n = leny)$y
if (leny > lenx)
sy <- approx(1L:leny, sy, n = lenx)$y
d <- data.frame(sx,sy)
ggplot(d,aes(sx,sy))+
geom_point(aes(colour=abs(sy-sx)),size=2)+
scale_colour_gradient(low='royalblue',high='royalblue4',guide='none')+
annotate("segment",x=-5,xend=5,y=-5,yend=5,colour="red")+
xlab("Theoretical Quantiles")+
ylab("Sample Quantiles")+
scale_x_continuous(breaks=seq(-5,5,2.5))+
scale_y_continuous(breaks=seq(-5,5,2.5))+
theme_bw()+
theme(
axis.title.y= element_text(size=rel(2),angle=90),
axis.title.x= element_text(size=rel(2)),
axis.text= element_text(size=rel(1.8))
)
}
n <- 50
n1 <- n
n2 <- n
pb <- txtProgressBar(style = 3)
myImproved <- vector()
myNew <- vector()
for (i in 1:nnn){
# data generation
X1 <- modelSimulator(n1)
X2 <- modelSimulator(n2)
myImproved[i] <- myStat2(X1,X2,n1,n2,r=r)$studentStat
myNew[i] <- myStatFinal(X1,X2,n1,n2,r=r)$studentStat
setTxtProgressBar(pb, i/nnn)
}
close(pb)
# Normal Q-Q plot
#x <- rnorm(n=100000)
#thePlot <- myQQplot(x,temp1)
#ggsave("QQplotOld1.eps",thePlot)
# chi-Squared Q-Q plot
x <- rchisq(n=100000,df=p-r)
x <- (x-(p-r))/sqrt(2*(p-r))
thePlot <- myQQplot(x,myImproved)
thePlot2 <- myQQplot(x,myNew)
thePlot
thePlot2
source("../stat.R")
library(ggplot2)
nnn <-500
#nnn <-5000
p <- 500
r <- 2
theEig <- rep(1,p)
beta <- 1
if(r!=0){
theEig[1:r] <- rep(1,r)*(p^beta)
}
temp <- newModelGenerator(theEig,theDistribution="normal")
modelSimulator <- temp$modelSimulator
myQQplot <- function(x,y){
sx <- sort(x)
sy <- sort(y)
lenx <- length(sx)
leny <- length(sy)
if (leny < lenx)
sx <- approx(1L:lenx, sx, n = leny)$y
if (leny > lenx)
sy <- approx(1L:leny, sy, n = lenx)$y
d <- data.frame(sx,sy)
ggplot(d,aes(sx,sy))+
geom_point(aes(colour=abs(sy-sx)),size=2)+
scale_colour_gradient(low='royalblue',high='royalblue4',guide='none')+
annotate("segment",x=-5,xend=5,y=-5,yend=5,colour="red")+
xlab("Theoretical Quantiles")+
ylab("Sample Quantiles")+
scale_x_continuous(breaks=seq(-5,5,2.5))+
scale_y_continuous(breaks=seq(-5,5,2.5))+
theme_bw()+
theme(
axis.title.y= element_text(size=rel(2),angle=90),
axis.title.x= element_text(size=rel(2)),
axis.text= element_text(size=rel(1.8))
)
}
n <- 50
n1 <- n
n2 <- n
pb <- txtProgressBar(style = 3)
myImproved <- vector()
myNew <- vector()
for (i in 1:nnn){
# data generation
X1 <- modelSimulator(n1)
X2 <- modelSimulator(n2)
myImproved[i] <- myStat2(X1,X2,n1,n2,r=r)$studentStat
myNew[i] <- myStatFinal(X1,X2,n1,n2,r=r)$studentStat
setTxtProgressBar(pb, i/nnn)
}
close(pb)
# Normal Q-Q plot
#x <- rnorm(n=100000)
#thePlot <- myQQplot(x,temp1)
#ggsave("QQplotOld1.eps",thePlot)
# chi-Squared Q-Q plot
x <- rchisq(n=100000,df=p-r)
x <- (x-(p-r))/sqrt(2*(p-r))
thePlot <- myQQplot(x,myImproved)
thePlot2 <- myQQplot(x,myNew)
thePlot
thePlot2
source("../stat.R")
library(ggplot2)
library(xtable)
simulateLevel <- function(n1,n2,p,r,beta,theDistribution="normal",B=20){
theEig <- rep(1,p)
if(r!=0){
theEig[1:r] <- rep(p^beta,r)+runif(r,0,1)
}
temp <- newModelGenerator(theEig,theDistribution=theDistribution)
modelSimulator <- temp$modelSimulator
V <- temp$V[,1:r]
myNew1Dis <- NULL
myNew2Dis <- NULL
myNew3Dis <- NULL
oracleDis <- NULL
chiDis <- NULL
fastDis <- NULL
CQDis <- NULL
SDDis <- NULL
ljwDis <- NULL
pb <- txtProgressBar(style=3)
for(i in 1:B){
# data generation
X1 <- modelSimulator(n1)
X2 <- modelSimulator(n2)
# precalculate the eigenvalue decomposition
S <- ((n1 - 1) * var(X1) + (n2 - 1) * var(X2)) / (n1 + n2 - 2)
myEigen <- eigen(S, symmetric = TRUE)
# NEW1
myNew1Dis[i] <- myStat(X1, X2, n1, n2, r=r, myEigen=myEigen)$studentStat
# NEW2
myNew2Dis[i] <- myStat2(X1, X2, n1, n2, r=r, myEigen=myEigen)$studentStat
# NEW3
myNew3Dis[i] <- myStatFinal(X1, X2, n1, n2, r=r, myEigen=myEigen)$studentStat
# oracle: V and sigma known
temp <- chenStat(X1%*%Null(V),X2%*%Null(V),n1,n2)$stat
oracleDis[i] <- n1*n2*temp/(sqrt(2*p)*(n1+n2)*1)
# chi
chiDis[i] <- myChiTest(X1, X2, n1, n2, r=r, myEigen=myEigen)
# fast
fastDis[i] <- maTest(X1, X2, n1, n2, r=r, myEigen=myEigen)
# CQ
CQDis[i] <- ChenQin.test(X1,X2)$ChQ
# SD
SDDis[i] <- sdStat(X1,X2, n1, n2, S=S)$stat
# LJW
ljwDis[i] <-ljwStat(X1,X2,n1,n2)
setTxtProgressBar(pb,i/B)
}
close(pb)
# NEW1
myNew1Level <- sum(pnorm(myNew1Dis,lower.tail=FALSE)<0.05)/B
#myNew1Level <- sum(pchisq(myNew1Dis*sqrt(2*(p-r))+p,lower.tail=FALSE)<0.05)/B
# NEW2
#myNew2Level <- sum(pnorm(myNew2Dis,lower.tail=FALSE)<0.05)/B
myNew2Level <- sum(pchisq(myNew2Dis*sqrt(2*(p-r))+p-r,df=p-r,lower.tail=FALSE)<0.05)/B
# NEW3
myNew3Level <- sum(pchisq(myNew3Dis*sqrt(2*(p-r))+p-r,df=p-r,lower.tail=FALSE)<0.05)/B
# ORACLE
#oracleLevel <- sum(pnorm(oracleDis,lower.tail=FALSE)<0.05)/B
oracleLevel <- sum(pchisq(oracleDis*sqrt(2*(p-r))+p-r,df=p-r,lower.tail=FALSE)<0.05)/B
# chi
chiLevel <- mean(chiDis)
# fast
fastLevel <- mean(fastDis)
# CQ
CQLevel <- sum(pnorm(CQDis,lower.tail=FALSE)<0.05)/B
# SD
SDLevel <- sum(pnorm(SDDis,lower.tail=FALSE)<0.05)/B
# LJW
ljwLevel <- mean(ljwDis)
list(New1=myNew1Level,
New2=myNew2Level,
New3=myNew3Level,
oracle=oracleLevel,
chi=chiLevel,
fast=fastLevel,
CQ=CQLevel,
SD=SDLevel,
ljw=ljwLevel
)
}
myOuterFun <- function(n,vecP){
for(theDistribution in c("normal","chiSquared","t")){
for(beta in c(0.5,1,2)){
Out=NULL
for(p in vecP){
r<-2
n1=n
n2=n
level <- simulateLevel(n1,n2,p,r,beta,theDistribution=theDistribution)
level <- cbind(level)
dimnames(level)[[2]] <- p
Out <- cbind(Out,level)
}
write.csv(Out,paste0(n,theDistribution,beta,".csv"))
}
}
}
myOuterFun(50,c(200,500,800))
source("../stat.R")
library(ggplot2)
library(xtable)
simulateLevel <- function(n1,n2,p,r,beta,theDistribution="normal",B=200){
theEig <- rep(1,p)
if(r!=0){
theEig[1:r] <- rep(p^beta,r)+runif(r,0,1)
}
temp <- newModelGenerator(theEig,theDistribution=theDistribution)
modelSimulator <- temp$modelSimulator
V <- temp$V[,1:r]
myNew1Dis <- NULL
myNew2Dis <- NULL
myNew3Dis <- NULL
oracleDis <- NULL
chiDis <- NULL
fastDis <- NULL
CQDis <- NULL
SDDis <- NULL
ljwDis <- NULL
pb <- txtProgressBar(style=3)
for(i in 1:B){
# data generation
X1 <- modelSimulator(n1)
X2 <- modelSimulator(n2)
# precalculate the eigenvalue decomposition
S <- ((n1 - 1) * var(X1) + (n2 - 1) * var(X2)) / (n1 + n2 - 2)
myEigen <- eigen(S, symmetric = TRUE)
# NEW1
myNew1Dis[i] <- myStat(X1, X2, n1, n2, r=r, myEigen=myEigen)$studentStat
# NEW2
myNew2Dis[i] <- myStat2(X1, X2, n1, n2, r=r, myEigen=myEigen)$studentStat
# NEW3
myNew3Dis[i] <- myStatFinal(X1, X2, n1, n2, r=r, myEigen=myEigen)$studentStat
# oracle: V and sigma known
temp <- chenStat(X1%*%Null(V),X2%*%Null(V),n1,n2)$stat
oracleDis[i] <- n1*n2*temp/(sqrt(2*p)*(n1+n2)*1)
# chi
chiDis[i] <- myChiTest(X1, X2, n1, n2, r=r, myEigen=myEigen)
# fast
fastDis[i] <- maTest(X1, X2, n1, n2, r=r, myEigen=myEigen)
# CQ
CQDis[i] <- ChenQin.test(X1,X2)$ChQ
# SD
SDDis[i] <- sdStat(X1,X2, n1, n2, S=S)$stat
# LJW
ljwDis[i] <-ljwStat(X1,X2,n1,n2)
setTxtProgressBar(pb,i/B)
}
close(pb)
# NEW1
myNew1Level <- sum(pnorm(myNew1Dis,lower.tail=FALSE)<0.05)/B
#myNew1Level <- sum(pchisq(myNew1Dis*sqrt(2*(p-r))+p,lower.tail=FALSE)<0.05)/B
# NEW2
#myNew2Level <- sum(pnorm(myNew2Dis,lower.tail=FALSE)<0.05)/B
myNew2Level <- sum(pchisq(myNew2Dis*sqrt(2*(p-r))+p-r,df=p-r,lower.tail=FALSE)<0.05)/B
# NEW3
myNew3Level <- sum(pchisq(myNew3Dis*sqrt(2*(p-r))+p-r,df=p-r,lower.tail=FALSE)<0.05)/B
# ORACLE
#oracleLevel <- sum(pnorm(oracleDis,lower.tail=FALSE)<0.05)/B
oracleLevel <- sum(pchisq(oracleDis*sqrt(2*(p-r))+p-r,df=p-r,lower.tail=FALSE)<0.05)/B
# chi
chiLevel <- mean(chiDis)
# fast
fastLevel <- mean(fastDis)
# CQ
CQLevel <- sum(pnorm(CQDis,lower.tail=FALSE)<0.05)/B
# SD
SDLevel <- sum(pnorm(SDDis,lower.tail=FALSE)<0.05)/B
# LJW
ljwLevel <- mean(ljwDis)
list(New1=myNew1Level,
New2=myNew2Level,
New3=myNew3Level,
oracle=oracleLevel,
chi=chiLevel,
fast=fastLevel,
CQ=CQLevel,
SD=SDLevel,
ljw=ljwLevel
)
}
myOuterFun <- function(n,vecP){
for(theDistribution in c("normal","chiSquared","t")){
for(beta in c(0.5,1,2)){
Out=NULL
for(p in vecP){
r<-2
n1=n
n2=n
level <- simulateLevel(n1,n2,p,r,beta,theDistribution=theDistribution)
level <- cbind(level)
dimnames(level)[[2]] <- p
Out <- cbind(Out,level)
}
write.csv(Out,paste0(n,theDistribution,beta,".csv"))
}
}
}
myOuterFun(50,c(200,500))
source("../stat.R")
library(ggplot2)
library(xtable)
simulateLevel <- function(n1,n2,p,r,beta,theDistribution="normal",B=500){
theEig <- rep(1,p)
if(r!=0){
theEig[1:r] <- rep(p^beta,r)+runif(r,0,1)
}
temp <- newModelGenerator(theEig,theDistribution=theDistribution)
modelSimulator <- temp$modelSimulator
V <- temp$V[,1:r]
myNew1Dis <- NULL
myNew2Dis <- NULL
myNew3Dis <- NULL
oracleDis <- NULL
chiDis <- NULL
fastDis <- NULL
CQDis <- NULL
SDDis <- NULL
ljwDis <- NULL
pb <- txtProgressBar(style=3)
for(i in 1:B){
# data generation
X1 <- modelSimulator(n1)
X2 <- modelSimulator(n2)
# precalculate the eigenvalue decomposition
S <- ((n1 - 1) * var(X1) + (n2 - 1) * var(X2)) / (n1 + n2 - 2)
myEigen <- eigen(S, symmetric = TRUE)
# NEW1
myNew1Dis[i] <- myStat(X1, X2, n1, n2, r=r, myEigen=myEigen)$studentStat
# NEW2
myNew2Dis[i] <- myStat2(X1, X2, n1, n2, r=r, myEigen=myEigen)$studentStat
# NEW3
myNew3Dis[i] <- myStatFinal(X1, X2, n1, n2, r=r, myEigen=myEigen)$studentStat
# oracle: V and sigma known
temp <- chenStat(X1%*%Null(V),X2%*%Null(V),n1,n2)$stat
oracleDis[i] <- n1*n2*temp/(sqrt(2*p)*(n1+n2)*1)
# chi
chiDis[i] <- myChiTest(X1, X2, n1, n2, r=r, myEigen=myEigen)
# fast
fastDis[i] <- maTest(X1, X2, n1, n2, r=r, myEigen=myEigen)
# CQ
CQDis[i] <- ChenQin.test(X1,X2)$ChQ
# SD
SDDis[i] <- sdStat(X1,X2, n1, n2, S=S)$stat
# LJW
ljwDis[i] <-ljwStat(X1,X2,n1,n2)
setTxtProgressBar(pb,i/B)
}
close(pb)
# NEW1
myNew1Level <- sum(pnorm(myNew1Dis,lower.tail=FALSE)<0.05)/B
#myNew1Level <- sum(pchisq(myNew1Dis*sqrt(2*(p-r))+p,lower.tail=FALSE)<0.05)/B
# NEW2
#myNew2Level <- sum(pnorm(myNew2Dis,lower.tail=FALSE)<0.05)/B
myNew2Level <- sum(pchisq(myNew2Dis*sqrt(2*(p-r))+p-r,df=p-r,lower.tail=FALSE)<0.05)/B
# NEW3
myNew3Level <- sum(pchisq(myNew3Dis*sqrt(2*(p-r))+p-r,df=p-r,lower.tail=FALSE)<0.05)/B
# ORACLE
#oracleLevel <- sum(pnorm(oracleDis,lower.tail=FALSE)<0.05)/B
oracleLevel <- sum(pchisq(oracleDis*sqrt(2*(p-r))+p-r,df=p-r,lower.tail=FALSE)<0.05)/B
# chi
chiLevel <- mean(chiDis)
# fast
fastLevel <- mean(fastDis)
# CQ
CQLevel <- sum(pnorm(CQDis,lower.tail=FALSE)<0.05)/B
# SD
SDLevel <- sum(pnorm(SDDis,lower.tail=FALSE)<0.05)/B
# LJW
ljwLevel <- mean(ljwDis)
list(New1=myNew1Level,
New2=myNew2Level,
New3=myNew3Level,
oracle=oracleLevel,
chi=chiLevel,
fast=fastLevel,
CQ=CQLevel,
SD=SDLevel,
ljw=ljwLevel
)
}
myOuterFun <- function(n,vecP){
for(theDistribution in c("normal","chiSquared","t")){
for(beta in c(0.5,1,2)){
Out=NULL
for(p in vecP){
r<-2
n1=n
n2=n
level <- simulateLevel(n1,n2,p,r,beta,theDistribution=theDistribution)
level <- cbind(level)
dimnames(level)[[2]] <- p
Out <- cbind(Out,level)
}
write.csv(Out,paste0(n,theDistribution,beta,".csv"))
}
}
}
myOuterFun(50,c(200))
